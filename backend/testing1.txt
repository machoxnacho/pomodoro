* Service: 
    * changed network mode from bridge to awsvpc
    * host port changed from 0 to 5000


* making a new target group
* target type: ip address because i am using awsvpc
* name: my-tg
* protocol HTTP 5000
* use /health
* change ALB listener to my-tg
* update service 
* use the lastest definition revision 
* under networking, choose VPC and ur associated subnets
* make new ecs-sg: name ecs-sg
* add inbound custom TCP , 5000, alb-sg, click create
* go back and add inbound ALL TCP for source of the ecs-sg
* go back to service and add the sg of the ecs-sg that youve just created 
* create. then go back and add load balancer
    * self explanitory
* Delete the instance you had so that asg can deploy a new one

aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 900546069136.dkr.ecr.us-east-1.amazonaws.com


docker buildx build \
  --platform linux/amd64 \
  -t 900546069136.dkr.ecr.us-east-1.amazonaws.com/smiski-backend:latest \
  --push .



server.js
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = 5000;

const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { DynamoDBDocumentClient, GetCommand, PutCommand, UpdateCommand } = require('@aws-sdk/lib-dynamodb');

// Replace with your region
const client = new DynamoDBClient({ region: 'us-east-1' });
const ddb = DynamoDBDocumentClient.from(client);

const TABLE_NAME = 'PomodoroUsers';

require('dotenv').config(); // loads variables from .env
const AWS = require('aws-sdk');
AWS.config.update({
    region: process.env.AWS_REGION, 
    accessKeyId: process.env.AWS_ACCESS_KEY_ID, 
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
});

app.use(cors());
app.use(express.json());

app.get('/health', (req, res) => {
  res.status(200).send('Smiski backend is healthy!');
});

app.get('/', (req, res) => {
  res.send('Smiski backend works!');
});

// GET current stats for a user
app.get('/stats/:userId', async (req, res) => {
  const { userId } = req.params;

  try {
    const data = await ddb.send(new GetCommand({
      TableName: TABLE_NAME,
      Key: { userId }
    }));

    if (!data.Item) {
      // Create user with default values if not found
      await ddb.send(new PutCommand({
        TableName: TABLE_NAME,
        Item: { userId, coins: 0, cycles: 0 }
      }));
      return res.json({ coins: 0, cycles: 0 });
    }

    res.json(data.Item);
  } catch (err) {
    console.error('Error fetching stats:', err);
    res.status(500).send('Failed to get stats');
  }
});

// POST to increment cycle and coins
app.post('/complete-cycle', async (req, res) => {
  const { userId } = req.body;

  try {
    const result = await ddb.send(new UpdateCommand({
      TableName: TABLE_NAME,
      Key: { userId },
      UpdateExpression: 'ADD coins :c, cycles :cy',
      ExpressionAttributeValues: {
        ':c': 5,
        ':cy': 1
      },
      ReturnValues: 'ALL_NEW'
    }));

    res.json({ message: 'Cycle completed', data: result.Attributes });
  } catch (err) {
    console.error('Error completing cycle:', err);
    res.status(500).send('Failed to complete cycle');
  }
});

app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
